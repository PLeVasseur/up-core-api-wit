// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod name {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() = super::super::__link_custom_section_describing_imports;
        use super::super::_rt;
        wit_bindgen_rt::bitflags::bitflags! {
            #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)] pub
            struct FlagType : u8 { const A = 1 << 0; const B = 1 << 1; const C = 1 << 2;
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        pub unsafe fn _export_dummy_cabi<T: Guest>(arg0: i32) -> i32 {
            #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
            let result0 = T::dummy(unsafe {
                wit_bindgen_rt::async_support::FutureReader::from_handle_and_vtable(
                    arg0 as u32,
                    &super::super::wit_future::vtable0::VTABLE,
                )
            });
            (result0).take_handle() as i32
        }
        pub trait Guest {
            fn dummy(
                name: wit_bindgen_rt::async_support::FutureReader<FlagType>,
            ) -> wit_bindgen_rt::async_support::FutureReader<FlagType>;
        }
        #[doc(hidden)]
        macro_rules! __export_name_cabi {
            ($ty:ident with_types_in $($path_to_types:tt)*) => {
                const _ : () = { #[unsafe (export_name = "name#dummy")] unsafe extern "C"
                fn export_dummy(arg0 : i32,) -> i32 { unsafe { $($path_to_types)*::
                _export_dummy_cabi::<$ty > (arg0) } } };
            };
        }
        #[doc(hidden)]
        pub(crate) use __export_name_cabi;
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::boxed::Box;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
}
pub mod wit_future {
    #![allow(dead_code, unused_variables, clippy::all)]
    #[doc(hidden)]
    pub trait FuturePayload: Unpin + Sized + 'static {
        const VTABLE: &'static wit_bindgen_rt::async_support::FutureVtable<Self>;
    }
    #[doc(hidden)]
    pub mod vtable0 {
        fn write(
            future: u32,
            value: super::super::exports::name::FlagType,
        ) -> ::core::pin::Pin<
            super::super::_rt::Box<dyn ::core::future::Future<Output = bool>>,
        > {
            super::super::_rt::Box::pin(async move {
                #[repr(align(1))]
                struct Buffer([::core::mem::MaybeUninit<u8>; 1]);
                let mut buffer = Buffer([::core::mem::MaybeUninit::uninit(); 1]);
                let address = buffer.0.as_mut_ptr() as *mut u8;
                unsafe {
                    let flags0 = &value;
                    *address.add(0).cast::<u8>() = ((flags0.bits() >> 0) as i32) as u8;
                }
                match unsafe {
                    wit_bindgen_rt::async_support::await_future_result(
                            start_write,
                            future,
                            address,
                        )
                        .await
                } {
                    wit_bindgen_rt::async_support::AsyncWaitResult::Values(_) => true,
                    wit_bindgen_rt::async_support::AsyncWaitResult::End => false,
                    wit_bindgen_rt::async_support::AsyncWaitResult::Error(_) => {
                        unreachable!("received error while performing write")
                    }
                }
            })
        }
        fn read(
            future: u32,
        ) -> ::core::pin::Pin<
            super::super::_rt::Box<
                dyn ::core::future::Future<
                    Output = ::std::option::Option<
                        ::std::result::Result<
                            super::super::exports::name::FlagType,
                            wit_bindgen_rt::async_support::ErrorContext,
                        >,
                    >,
                >,
            >,
        > {
            super::super::_rt::Box::pin(async move {
                struct Buffer([::core::mem::MaybeUninit<u8>; 1]);
                let mut buffer = Buffer([::core::mem::MaybeUninit::uninit(); 1]);
                let address = buffer.0.as_mut_ptr() as *mut u8;
                match unsafe {
                    wit_bindgen_rt::async_support::await_future_result(
                            start_read,
                            future,
                            address,
                        )
                        .await
                } {
                    wit_bindgen_rt::async_support::AsyncWaitResult::Values(v) => {
                        let value = unsafe {
                            let l0 = i32::from(*address.add(0).cast::<u8>());
                            super::super::exports::name::FlagType::empty()
                                | super::super::exports::name::FlagType::from_bits_retain(
                                    ((l0 as u8) << 0) as _,
                                )
                        };
                        Some(Ok(value))
                    }
                    wit_bindgen_rt::async_support::AsyncWaitResult::Error(e) => {
                        Some(
                            Err(
                                wit_bindgen_rt::async_support::ErrorContext::from_handle(e),
                            ),
                        )
                    }
                    wit_bindgen_rt::async_support::AsyncWaitResult::End => None,
                }
            })
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_write(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn cancel_read(_: u32) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn close_writable(_: u32, _: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn close_readable(_: u32, _: u32) {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn new() -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_read(_: u32, _: *mut u8) -> u32 {
            unreachable!()
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn start_write(_: u32, _: *mut u8) -> u32 {
            unreachable!()
        }
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "[export]name")]
        unsafe extern "C" {
            #[link_name = "[future-new-0]dummy"]
            fn new() -> u32;
            #[link_name = "[future-cancel-write-0]dummy"]
            fn cancel_write(_: u32) -> u32;
            #[link_name = "[future-cancel-read-0]dummy"]
            fn cancel_read(_: u32) -> u32;
            #[link_name = "[future-close-writable-0]dummy"]
            fn close_writable(_: u32, _: u32);
            #[link_name = "[future-close-readable-0]dummy"]
            fn close_readable(_: u32, _: u32);
            #[link_name = "[async-lower][future-read-0]dummy"]
            fn start_read(_: u32, _: *mut u8) -> u32;
            #[link_name = "[async-lower][future-write-0]dummy"]
            fn start_write(_: u32, _: *mut u8) -> u32;
        }
        pub static VTABLE: wit_bindgen_rt::async_support::FutureVtable<
            super::super::exports::name::FlagType,
        > = wit_bindgen_rt::async_support::FutureVtable::<
            super::super::exports::name::FlagType,
        > {
            write,
            read,
            cancel_write,
            cancel_read,
            close_writable,
            close_readable,
            new,
        };
        impl super::FuturePayload for super::super::exports::name::FlagType {
            const VTABLE: &'static wit_bindgen_rt::async_support::FutureVtable<Self> = &VTABLE;
        }
    }
    /// Creates a new Component Model `future` with the specified payload type.
    pub fn new<T: FuturePayload>() -> (
        wit_bindgen_rt::async_support::FutureWriter<T>,
        wit_bindgen_rt::async_support::FutureReader<T>,
    ) {
        unsafe { wit_bindgen_rt::async_support::future_new::<T>(T::VTABLE) }
    }
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_name_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: exports::name::__export_name_cabi!($ty with_types_in
        $($path_to_types_root)*:: exports::name);
    };
}
#[doc(inline)]
pub(crate) use __export_name_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.41.0:y:name:name:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 205] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07S\x01A\x02\x01A\x02\x01\
B\x05\x01n\x03\x01a\x01b\x01c\x04\0\x09flag-type\x03\0\0\x01e\x01\x01\x01@\x01\x04\
name\x02\0\x02\x04\0\x05dummy\x01\x03\x04\0\x04name\x05\0\x04\0\x0by:name/name\x04\
\0\x0b\x0a\x01\0\x04name\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-\
component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
